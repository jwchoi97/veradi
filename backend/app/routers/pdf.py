from __future__ import annotations

import uuid
from datetime import datetime

from fastapi import APIRouter, Depends, File, Form, Header, HTTPException, UploadFile
from sqlalchemy.orm import Session

from ..authz import ensure_can_manage_project
from ..mariadb.database import SessionLocal
from ..mariadb.models import FileAsset, ReviewSession
from ..minio.service import upload_stream
from .auth import get_current_user
from ..utils.storage_derivation import derive_baked_key

router = APIRouter(prefix="/pdf", tags=["pdf"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@router.post("/save")
async def save_pdf_with_annotations(
    file: UploadFile = File(...),
    file_id: int = Form(...),
    db: Session = Depends(get_db),
    x_user_id: str | None = Header(default=None),
):
    """
    Save an annotated PDF (bytes generated by pdf.js saveDocument()).
    - No JSON persistence: we store the baked PDF only.
    - No download: caller uploads via multipart/form-data.
    """
    user = get_current_user(db, x_user_id)

    asset = db.query(FileAsset).filter(FileAsset.id == file_id).first()
    if not asset:
        raise HTTPException(status_code=404, detail="File not found")

    project = asset.project
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    ensure_can_manage_project(user, project)

    session = db.query(ReviewSession).filter(
        ReviewSession.file_asset_id == file_id,
        ReviewSession.user_id == user.id,
    ).first()
    if not session:
        session = ReviewSession(
            file_asset_id=file_id,
            user_id=user.id,
            status="in_progress",
            started_at=datetime.utcnow(),
        )
        db.add(session)
        db.commit()
        db.refresh(session)

    original_name = file.filename or f"annotated-{file_id}.pdf"
    object_key = derive_baked_key(asset.file_key, user_id=user.id)

    try:
        up = upload_stream(
            project_id=asset.project_id,
            fileobj=file.file,
            original_filename=original_name,
            content_type="application/pdf",
            object_key=object_key,
        )
    except RuntimeError as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        try:
            await file.close()
        except Exception:
            pass

    return {"file_id": file_id, "object_key": up.object_key}

