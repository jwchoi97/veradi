from __future__ import annotations

import uuid
from datetime import datetime

from fastapi import APIRouter, Depends, File, Form, Header, HTTPException, UploadFile
from sqlalchemy.orm import Session

from ..authz import ensure_can_manage_project
from ..mariadb.database import SessionLocal
from ..mariadb.models import FileAsset, Review
from ..minio.service import upload_stream
from .auth import get_current_user

router = APIRouter(prefix="/pdf", tags=["pdf"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@router.post("/save")
async def save_pdf_with_annotations(
    file: UploadFile = File(...),
    file_id: int = Form(...),
    db: Session = Depends(get_db),
    x_user_id: str | None = Header(default=None),
):
    """
    Save an annotated PDF (bytes generated by pdf.js saveDocument()).
    - No JSON persistence: we store the baked PDF only.
    - No download: caller uploads via multipart/form-data.
    """
    user = get_current_user(db, x_user_id)

    asset = db.query(FileAsset).filter(FileAsset.id == file_id).first()
    if not asset:
        raise HTTPException(status_code=404, detail="File not found")

    project = asset.project
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    ensure_can_manage_project(user, project)

    # Ensure a Review exists (we reuse review namespace for storage location)
    review = db.query(Review).filter(Review.file_asset_id == file_id).first()
    if not review:
        review = Review(file_asset_id=file_id, status="pending")
        db.add(review)
        db.commit()
        db.refresh(review)

    original_name = file.filename or f"annotated-{file_id}.pdf"
    object_key = f"reviews/{review.id}/annotated/{uuid.uuid4().hex}.pdf"

    try:
        up = upload_stream(
            project_id=asset.project_id,
            fileobj=file.file,
            original_filename=original_name,
            content_type="application/pdf",
            object_key=object_key,
        )
    except RuntimeError as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        try:
            await file.close()
        except Exception:
            pass

    # Replace the underlying stored PDF for this FileAsset (same file_id keeps working)
    asset.file_key = up.object_key
    asset.mime_type = "application/pdf"
    asset.updated_at = datetime.utcnow()
    db.add(asset)
    db.commit()

    return {"file_id": file_id, "object_key": up.object_key}

